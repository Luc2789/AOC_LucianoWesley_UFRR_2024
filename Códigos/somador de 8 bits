from z3 import *

# Definir o tamanho do somador (8 bits)
n_bits = 8

# Criar o Solver Z3
solver = Solver()

# Definir as variáveis de entrada A, B e Carry In (C_in) para cada bit
A = [Bool(f"A_{i}") for i in range(n_bits)]
B = [Bool(f"B_{i}") for i in range(n_bits)]
C_in = Bool('C_in')

# Definir as variáveis de saída Soma e Carry Out para cada bit
S = [Bool(f"S_{i}") for i in range(n_bits)]
C_out = Bool('C_out')

# Definir as expressões para soma e carry out para um somador completo de 1 bit
def somador_completo(A_i, B_i, C_in):
    # Soma S = A XOR B XOR C_in
    soma = Xor(A_i, B_i, C_in)
    
    # Carry out C_out = (A AND B) OR (B AND C_in) OR (A AND C_in)
    carry_out = Or(And(A_i, B_i), And(B_i, C_in), And(A_i, C_in))
    
    return soma, carry_out

# Adicionar as restrições para todos os 8 bits
carry_in = C_in
for i in range(n_bits):
    soma, carry_out = somador_completo(A[i], B[i], carry_in)
    solver.add(S[i] == soma)  # A saída da soma
    if i < n_bits - 1:
        carry_in = carry_out  # O carry out se torna o carry in para o próximo bit
    else:
        solver.add(C_out == carry_out)  # O carry final é o carry out do último bit

# Função para verificar a validade do somador
def verificar_validade():
    # Verificar para todas as combinações de A, B, e C_in
    for a in range(2**n_bits):
        for b in range(2**n_bits):
            for c in [0, 1]:  # Considerar C_in = 0 ou 1
                # Definir as entradas no solver
                entradas_A = [bool((a >> i) & 1) for i in range(n_bits)]
                entradas_B = [bool((b >> i) & 1) for i in range(n_bits)]
                entradas_C_in = bool(c)

                solver.push()
                
                # Atribuir as entradas no solver
                for i in range(n_bits):
                    solver.add(A[i] == entradas_A[i])
                    solver.add(B[i] == entradas_B[i])
                solver.add(C_in == entradas_C_in)
                
                # Verificar se a soma gerada é válida
                if solver.check() == sat:
                    model = solver.model()
                    soma_resultante = [model[S[i]].as_bool() for i in range(n_bits)]
                    soma_esperada = [bool(((entradas_A[i] + entradas_B[i] + entradas_C_in) >> i) & 1) for i in range(n_bits)]
                    
                    if soma_resultante != soma_esperada:
                        print(f"Erro encontrado para A={a:08b}, B={b:08b}, C_in={c}: soma esperada {soma_esperada} mas a soma gerada foi {soma_resultante}")
                solver.pop()

    print("Verificação completa!")

# Verificar a validade do somador
verificar_validade()
